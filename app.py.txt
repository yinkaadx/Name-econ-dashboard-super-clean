import streamlit as st
import pandas as pd
import numpy as np
from fredapi import Fred
import wbdata
import requests
from bs4 import BeautifulSoup
import yfinance as yf
import sqlite3
from concurrent.futures import ThreadPoolExecutor
import plotly.express as px
import re
import smtplib
from email.mime.text import MIMEText

# Get keys from st.secrets (Cloud) or fallback to env (local)
fred_api_key = st.secrets.get('FRED_API_KEY')
fred = Fred(api_key=fred_api_key) if fred_api_key else None

# Theme: Dark (Streamlit auto)
st.set_page_config(layout="wide", initial_sidebar_state="expanded")

# Indicators with easy desc, threshold, fetch (FRED/WB/yfinance/scraper)
indicators = {
    'GDP': {'fetch': lambda: fred.get_series('GDP')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Total economic output - high is good growth'},
    'GDP Gap': {'fetch': lambda: fred.get_series('GDPPOT')[-1] - fred.get_series('GDP')[-1] if fred else np.nan, 'thresh': 0, 'desc': 'Gap to potential GDP - positive means room to grow'},
    'GDP per Capita': {'fetch': lambda: wbdata.get_series('NY.GDP.PCAP.CD')['USA'], 'thresh': np.nan, 'desc': 'Income per person - rising means better living standards'},
    'GDP Share': {'fetch': lambda: wbdata.get_series('NY.GDP.MKTP.CD')['USA'] / wbdata.get_series('NY.GDP.MKTP.CD')['WLD'] * 100, 'thresh': np.nan, 'desc': 'US GDP as % of world - high means global dominance'},
    'Economic Output Share': {'fetch': lambda: wbdata.get_series('NY.GDP.MKTP.CD')['USA'] / wbdata.get_series('NY.GDP.MKTP.CD')['WLD'] * 100, 'thresh': np.nan, 'desc': 'Share of global economy - falling means decline'},
    'Unemployment Rate': {'fetch': lambda: fred.get_series('UNRATE')[-1] if fred else np.nan, 'thresh': 5, 'desc': ' % jobless - low is healthy economy'},
    'Unemployment Claims': {'fetch': lambda: fred.get_series('ICSA')[-1] if fred else np.nan, 'thresh': 300000, 'desc': 'Weekly jobless claims - rising means trouble'},
    'Nonfarm Payrolls': {'fetch': lambda: fred.get_series('PAYEMS')[-1] - fred.get_series('PAYEMS')[-2] if fred else np.nan, 'thresh': 150000, 'desc': 'Monthly job adds - >150K is strong'},
    'Wage Growth': {'fetch': lambda: fred.get_series('AHETPI')[-1] if fred else np.nan, 'thresh': 3, 'desc': 'Hourly earnings growth - >3% means rising pay'},
    'Inflation Rate': {'fetch': lambda: fred.get_series('CPIAUCSL')[-1] if fred else np.nan, 'thresh': 3, 'desc': 'Price rise % - high erodes money value'},
    'Deflation': {'fetch': lambda: fred.get_series('CPIAUCSL')[-1] if fred else np.nan, 'thresh': 0, 'desc': 'Negative inflation - prices falling hurts economy'},
    'Consumer Confidence Index': {'fetch': lambda: fred.get_series('UMCSENT')[-1] if fred else np.nan, 'thresh': 90, 'desc': 'Consumer mood - >90 means optimistic'},
    'Consumer Spending': {'fetch': lambda: fred.get_series('PCE')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Personal spending - high drives growth'},
    'Retail Sales Growth': {'fetch': lambda: fred.get_series('RSXFS')[-1] if fred else np.nan, 'thresh': 3, 'desc': 'Retail sales % change - >3% means strong shoppers'},
    'Industrial Production': {'fetch': lambda: fred.get_series('INDPRO')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Factory output - high means busy industries'},
    'Inventory Levels': {'fetch': lambda: fred.get_series('ISRATIO')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Inventory to sales ratio - low means high demand'},
    'Building Permits': {'fetch': lambda: fred.get_series('PERMIT')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'New home permits - rising means construction boom'},
    'Capacity Utilization': {'fetch': lambda: fred.get_series('CAPUTL')[-1] if fred else np.nan, 'thresh': 80, 'desc': 'Factory usage % - >80% means overheating'},
    'Productivity Growth': {'fetch': lambda: fred.get_series('OPHNFB')[-1] if fred else np.nan, 'thresh': 3, 'desc': 'Output per hour % - >3% means efficiency gains'},
    'P/E Ratio': {'fetch': lambda: scrape_multpl_pe(), 'thresh': 25, 'desc': 'Stock price to earnings - >25 means overvalued'},
    'Stock Market Return': {'func': lambda: yf.Ticker('^GSPC').history(period='1y')['Close'].pct_change().mean() * 100, 'thresh': 10, 'desc': 'S&P yearly % return - high means good gains'},
    'Asset Prices': {'fetch': lambda: yf.Ticker('^GSPC').info.get('regularMarketPrice', np.nan), 'thresh': np.nan, 'desc': 'Asset price level - high means bubble risk'},
    'Asset Returns': {'fetch': lambda: yf.Ticker('^GSPC').history(period='1d')['Close'][0], 'thresh': np.nan, 'desc': 'Daily asset return - positive is good'},
    'Asset Bubbles': {'fetch': lambda: yf.Ticker('^GSPC').info.get('regularMarketPrice', np.nan) / fred.get_series('PCE')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Asset to PCE ratio - high means bubble'},
    'Debt-to-GDP': {'fetch': lambda: (fred.get_series('GFDEBTN')[-1] / fred.get_series('GDP')[-1]) * 100 if fred else np.nan, 'thresh': 100, 'desc': 'Debt % of GDP - >100% means high burden'},
    'Debt Growth': {'fetch': lambda: fred.get_series('GFDEBTN')[-1] - fred.get_series('GFDEBTN')[-4] if fred else np.nan, 'thresh': 5, 'desc': 'Debt increase % - >5% means fast borrowing'},
    'Debt Service': {'fetch': lambda: fred.get_series('FGDS')[-1] if fred else np.nan, 'thresh': 20, 'desc': 'Debt payment % of income - >20% means strain'},
    'Leverage': {'fetch': lambda: fred.get_series('NFSDB')[-1] / fred.get_series('GDP')[-1] * 100 if fred else np.nan, 'thresh': 80, 'desc': 'Household debt % GDP - >80% means high leverage'},
    'Credit Growth': {'fetch': lambda: fred.get_series('TOTALSL')[-1] - fred.get_series('TOTALSL')[-4] if fred else np.nan, 'thresh': 5, 'desc': 'Credit expansion % - >5% means loose lending'},
    'Defaults': {'fetch': lambda: scrape_moodys_defaults(), 'thresh': 5, 'desc': 'Default rate % - >5% means credit trouble'},
    'Short Rates': {'fetch': lambda: fred.get_series('FEDFUNDS')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Short-term interest rate - rising slows economy'},
    'Real Rates': {'fetch': lambda: fred.get_series('FEDFUNDS')[-1] - fred.get_series('CPIAUCSL')[-1] if fred else np.nan, 'thresh': 0, 'desc': 'Rates minus inflation - positive hurts borrowing'},
    'Central Bank Rate': {'fetch': lambda: fred.get_series('FEDFUNDS')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Fed funds rate - high means tightening'},
    'Yield Curve Slope': {'fetch': lambda: fred.get_series('T10Y2Y')[-1] if fred else np.nan, 'thresh': 0, 'desc': '10Y-2Y yield spread - negative signals recession'},
    'Credit Spreads': {'fetch': lambda: fred.get_series('BAAFF')[-1] if fred else np.nan, 'thresh': 5, 'desc': 'Corporate bond spread - wide means risk aversion'},
    'Currency Devaluation': {'fetch': lambda: fred.get_series('EXUSUK')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'USD exchange rate - falling means devaluation'},
    'Fed Funds Futures Rate': {'fetch': lambda: fred.get_series('FEDFUNDS')[-1] + 0.5 if fred else np.nan, 'thresh': 0.5, 'desc': 'Expected Fed rate - rising means hikes'},
    'M2 Money Supply': {'func': lambda: fred.get_series('M2SL')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Money supply - high means inflation risk'},
    'Fiscal Deficits': {'fetch': lambda: fred.get_series('MTSDS133FMS')[-1] if fred else np.nan, 'thresh': 6, 'desc': 'Deficit % GDP - >6% means high spending'},
    'Leading Economic Index (LEI)': {'fetch': lambda: fred.get_series('USSLIND')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'LEI index - falling signals downturn'},
    'Competitiveness Index': {'fetch': lambda: scrape_wef_competitiveness(), 'thresh': np.nan, 'desc': 'Global competitiveness score - high means strong economy'},
    'Power Index': {'func': lambda: scrape_globalfirepower_index(), 'thresh': np.nan, 'desc': 'Military power score - low means weakness'},
    'Corruption Index': {'func': lambda: scrape_transparency_cpi(), 'thresh': 50, 'desc': 'Corruption perception - <50 means high graft'},
    'Military Spending': {'func': lambda: scrape_sipri_military(), 'thresh': 4, 'desc': 'Military % GDP - >4% means strain'},
    'Foreign Reserves': {'fetch': lambda: fred.get_series('TRESEGT')[-1] if fred else np.nan, 'thresh': np.nan, 'desc': 'Foreign reserves - falling means vulnerability'},
    'Trade Balance': {'fetch': lambda: fred.get_series('NETEXP')[-1] if fred else np.nan, 'thresh': 2, 'desc': 'Trade surplus % GDP - positive means strength'},
    'Trade Share': {'fetch': lambda: wbdata.get_series('NE.TRD.GNFS.ZS')['USA'], 'thresh': 15, 'desc': 'Trade % global - >15% means dominance'},
    'R&D Patents': {'fetch': lambda: wbdata.get_series('IP.PAT.RESD')['USA'], 'thresh': np.nan, 'desc': 'Patents filed - high means innovation'},
    'Education Investment': {'fetch': lambda: wbdata.get_series('SE.XPD.TOTL.GD.ZS')['USA'], 'thresh': 5, 'desc': 'Education % GDP - >5% means investment'},
    'Internal Conflicts': {'fetch': lambda: scrape_conflicts_index(), 'thresh': 20, 'desc': 'Protest count - >20 means unrest'},
    'Wealth Gaps': {'fetch': lambda: wbdata.get_series('SI.POV.GINI')['USA'], 'thresh': 40, 'desc': 'Gini index - >40 means inequality'},
    'Demographic Aging': {'fetch': lambda: wbdata.get_series('SP.POP.65UP.TO.ZS')['USA'], 'thresh': 1, 'desc': 'Aging population % change - >1% means older workforce'},
    'Reserve Currency Usage': {'fetch': lambda: scrape_reserve_currency_share(), 'thresh': 50, 'desc': 'USD % reserves - <50% means decline'},
}

# Additional scraper for missing fetch methods
def scrape_wef_competitiveness():
    try:
        r = requests.get('https://www.weforum.org/reports/global-competitiveness-report-2025')
        soup = BeautifulSoup(r.text, 'html.parser')
        score = soup.find(string=re.compile(r'US score \d+'))
        return float(re.search(r'\d+', score).group()) if score else np.nan
    except:
        return np.nan

def scrape_conflicts_index():
    try:
        r = requests.get('https://www.globalconflicttracker.org/')
        soup = BeautifulSoup(r.text, 'html.parser')
        count = len(soup.find_all('div', class_='conflict-item'))
        return count
    except:
        return np.nan

def scrape_reserve_currency_share():
    try:
        r = requests.get('https://www.imf.org/en/Data')
        soup = BeautifulSoup(r.text, 'html.parser')
        usd_share = soup.find(string=re.compile(r'USD reserves \d+%'))
        return float(re.search(r'\d+', usd_share).group()) if usd_share else np.nan
    except:
        return np.nan

@st.cache_data(ttl=3600)  # Cache for 1 hour
def fetch_all():
    data = {}
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = {name: executor.submit(ind['func']) for name, ind in indicators.items()}
        for name, future in futures.items():
            try:
                data[name] = future.result()
            except Exception as e:
                data[name] = np.nan  # Silent fail to NaN
    return data

conn = sqlite3.connect('econ.db')

st.title('Econ Mirror Dashboard - July 20 2025')

tab1, tab2 = st.tabs(["Indicators", "Investment Risks"])

with tab1:
    if st.button('Refresh Now'):
        data = fetch_all()
        df = pd.DataFrame(list(data.items()), columns=['Indicator', 'Value'])
        df.to_sql('data', conn, if_exists='replace')
    else:
        df = pd.read_sql('SELECT * FROM data', conn)

    col1, col2 = st.columns(2)
    with col1:
        st.subheader('Indicators Viz')
        for _, row in df.iterrows():
            thresh = indicators.get(row['Indicator'], {}).get('thresh', np.nan)
            value = row['Value'] if isinstance(row['Value'], (int, float)) else np.nan
            if np.isnan(value):
                continue
            color = 'red' if not np.isnan(thresh) and value > thresh else 'green'
            fig = px.bar(x=[row['Indicator']], y=[value], color_discrete_sequence=[color], title=indicators.get(row['Indicator'], {}).get('desc', ''))
            fig.update_traces(hovertemplate='Value: %{y}<br>Desc: %{title}')
            st.plotly_chart(fig, use_container_width=True)

    with col2:
        st.subheader('Indicators Table')
        st.dataframe(df)

with tab2:
    st.subheader('Investment Risks Measurement')
    # Package risks as scores (0-100) based on indicators
    risks = {
        'Market Risk': {'indicators': ['Stock Market Return'], 'score': np.clip(100 - (data.get('Stock Market Return', 0) * 5), 0, 100), 'desc': 'Price drops from market moves - high score = high risk'},
        'Volatility Risk': {'indicators': ['Volatility Risk'], 'score': data.get('Volatility Risk', 0) * 5 if data.get('Volatility Risk', 0) > 0 else 0, 'desc': 'Sudden asset swings - high score = high risk'},
        'Credit Risk': {'indicators': ['Credit Risk'], 'score': data.get('Credit Risk', 0) * 20, 'desc': 'Bond defaults - high score = high risk'},
        'Interest Rate Risk': {'indicators': ['Interest Rate Risk'], 'score': data.get('Interest Rate Risk', 0) * 20, 'desc': 'Rising rates hurt bonds - high score = high risk'},
        'Currency Risk': {'indicators': ['Currency Devaluation'], 'score': abs(data.get('Currency Devaluation', 0) - 1) * 100, 'desc': 'Exchange rate losses - high score = high risk'},
        'Liquidity Risk': {'indicators': ['Credit Spreads'], 'score': data.get('Credit Spreads', 0) * 20, 'desc': 'Can’t sell fast - high score = high risk'},
        'Inflation Risk': {'indicators': ['Inflation Rate'], 'score': data.get('Inflation Rate', 0) * 33, 'desc': 'Erodes returns - high score = high risk'},
        'Deflation Risk': {'indicators': ['Deflation'], 'score': 100 if data.get('Deflation', 0) < 0 else 0, 'desc': 'Price collapse - high score = high risk'},
        'Geopolitical Risk': {'indicators': ['Power Index', 'Internal Conflicts'], 'score': (100 - data.get('Power Index', 0) * 10) + data.get('Internal Conflicts', 0) * 5, 'desc': 'Wars/trade wars - high score = high risk'},
        'Policy Risk': {'indicators': ['Central Bank Rate'], 'score': abs(data.get('Central Bank Rate', 0) - 2) * 25, 'desc': 'Unexpected policy moves - high score = high risk'},
        'Concentration Risk': {'indicators': ['Trade Share'], 'score': 100 - data.get('Trade Share', 0) * 5, 'desc': 'Overweight single asset - high score = high risk'},
        'Leverage Risk': {'indicators': ['Leverage'], 'score': data.get('Leverage', 0), 'desc': 'Amplified losses - high score = high risk'},
        'Operational Risk': {'indicators': ['Corruption Index'], 'score': 100 - data.get('Corruption Index', 0), 'desc': 'Errors/fraud - high score = high risk'},
        'Counterparty Risk': {'indicators': ['Defaults'], 'score': data.get('Defaults', 0) * 20, 'desc': 'Other party defaults - high score = high risk'},
        'Model Risk': {'indicators': ['Leading Economic Index (LEI)'], 'score': 100 if data.get('Leading Economic Index (LEI)', 0) < 0 else 0, 'desc': 'Flawed strategy - high score = high risk'},
        'Regulatory Risk': {'indicators': ['Fiscal Deficits'], 'score': data.get('Fiscal Deficits', 0) * 16, 'desc': 'New laws hurt - high score = high risk'},
        'Environmental Risk': {'indicators': ['GDP Gap'], 'score': abs(data.get('GDP Gap', 0)) * 50, 'desc': 'Climate events - high score = high risk'},
        'Tail Risk': {'indicators': ['Volatility Risk'], 'score': data.get('Volatility Risk', 0) * 5, 'desc': 'Black swan events - high score = high risk'},
        'Drawdown Risk': {'indicators': ['Stock Market Return'], 'score': 100 if data.get('Stock Market Return', 0) < 0 else 0, 'desc': 'Prolonged losses - high score = high risk'},
        'Ruin Risk': {'indicators': ['Debt-to-GDP'], 'score': data.get('Debt-to-GDP', 0), 'desc': 'Total capital loss - high score = high risk'},
}

    risk_df = pd.DataFrame([{'Risk': name, 'Score': ind['score'], 'Desc': ind['desc'], 'Based on': ', '.join(ind['indicators'])} for name, ind in risks.items()])
    for _, row in risk_df.iterrows():
        st.metric(row['Risk'], f"{row['Score']:.1f}%", row['Desc'])
        st.progress(row['Score'] / 100)

# Alerts
breaches = df[df.apply(lambda row: isinstance(row['Value'], (int, float)) and row['Value'] > indicators.get(row['Indicator'], {}).get('thresh', np.nan), axis=1)]
if not breaches.empty:
    try:
        msg = MIMEText(f'Flood: {breaches.to_string()}')
        msg['Subject'] = 'Econ Breach Alert'
        msg['From'] = st.secrets['EMAIL_USER']
        msg['To'] = st.secrets['EMAIL_TO']
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(st.secrets['EMAIL_USER'], st.secrets['EMAIL_PASS'])
            server.send_message(msg)
        st.warning('Alert emailed!')
    except Exception as e:
        st.error(f'Email failed: {e}')